Example Code: Routing Service Processor
***************************************

.. |RS| replace:: *RoutingService*
.. |PROCESSOR| replace:: *Processor*
.. |SD| replace:: *ShapesDemo*.

Below there are the instructions to build and run this example. All the commands
and syntax used assume a Unix-based system. If you run this example in a different
architecture, please adapt the commands accordingly.

Building
========

To build the example you will need first to run CMake to generate the build files.
From the directory containing the example sources:

::

    mkdir build
    cd build
    cmake -DCONNEXTDDS_DIR=<Connext directory> \
            -DCONNEXTDDS_ARCH=<ARCH> \
            -DCMAKE_BUILD_TYPE=Release \
            -DBUILD_SHARED_LIBS=ON ..
    cmake --build .


where:

- ``<Connext directory>`` shall be replaced with the path to the installation
  directory of *RTI Connext*.
- ``<ARCH>`` shall be replaced with the target architecture where you are
  running the example (e.g., x64Darwin15clang7.0).

.. note::

    For certain CMake generators you may need to provide the target platform
    through the ``-A`` command-line option. For example on Windows systems, you
    can provide the values ``Win32`` or ``x64``

.. note::

    Certain `CMake generators <https://cmake.org/cmake/help/latest/manual/cmake-generators.7.html>`_
    generate multi-configuration files may need explicit selection of the
    configuration through ``--config``. For example for Visual Studio 2015, by
    default you can select ``Release`` or ``Debug``.

Upon success of the previous command it will create a shared library file in
the build directory.


Running
=======

To run this example you will need two instances of *RTI Shapes Demo* and a single
instance of |RS|.

To run |RS|, you will need first to set up your environment as follows:

::

    export RTI_LD_LIBRARY_PATH=<Connext directory>/lib/<ARCH>

where ``<ARCH>`` shall be replaced with the target architecture you used to
build the example in the previous step.

If the shared library of this example, generated in the previous build phase,
is placed in a different directory other than your current working directory,
you will need to add the path to your environment. For example:

::

    export RTI_LD_LIBRARY_PATH=$RTI_LD_LIBRARY_PATH:$PWD/Debug/x64


Aggregation (Simple)
--------------------

#. Run one instance of |SD| on domain 0. This will be the publisher application.
   Publish a blue squares and blue circles.

#. Run the other instance of |SD| on domain 1. This will be the subscriber
   application.
   Subscribe to squares, circles and triangles and observe how no data is received.

#. Now run |RS| to cause the aggregation data from the publisher application
   to the subscriber application.  Run the following command from the example
   build directory:

   ::

        <Connext directory>/bin/rtiroutingservice \
                -cfgFile ../RsShapesProcessor.xml \
                -cfgName RsShapesAggregator \
                -DSHAPES_PROC_KIND=aggregator_simple


   You should see how the subscriber application receives samples from squares,
   circles and triangles. The squares and circles samples are exactly the same
   generated by the publisher application. The triangles are follow the same
   direction than the squares, with their size changing depending on the position
   of the circles.

   Note that we are using the configuration variable ``SHAPES_PROC_KIND`` to
   indicate which class we want to instantiate, and its value is provided
   with the ``-D`` command-line option.

#. Repeat the first step but publish other colors. You should observe the same
   behavior in the subscriber application for the new colors.

#. In the publisher application, delete all the *DataWriters*. You should
   see the instances being disposed. Now delete all *DataReaders* from the
   subscriber application.

Aggregation (Advanced)
----------------------

#. Run one instance of |SD| on domain 0. This will be the publisher application.
   Publish a blue squares and blue circles.

#. Run the other instance of |SD| on domain 1. This will be the subscriber
   application.
   Subscribe to squares, circles and triangles and observe how no data is received.

#. Now run |RS| to cause the aggregation data from the publisher application
   to the subscriber application.  Run the following command from the example
   build directory:

   ::

        <Connext directory>/bin/rtiroutingservice \
                -cfgFile ../RsShapesProcessor.xml \
                -cfgName RsShapesAggregator \
                -DSHAPES_PROC_KIND=aggregator_adv


   You should see how the subscriber application receives samples from squares,
   circles and triangles. The squares and circles samples are exactly the same
   generated by the publisher application. The triangles are samples are the
   result of the route that contains the *ShapesAggegator*.

   Note that we are using the configuration variable ``SHAPES_PROC_KIND`` to
   indicate which class we want to instantiate, and its value is provided
   with the ``-D`` command-line option.

#. Repeat the first step but publish other colors. You should observe the same
   behavior in the subscriber application for the new colors.

#. In the publisher application, delete all the *DataWriters*. You should
   see the instances being disposed. Now delete all *DataReaders* from the
   subscriber application.



Splitter
--------

#. Run one instance of |SD| on domain 0. This will be the publisher application.
   Publish a blue squares.

#. Run the other instance of |SD| on domain 1. This will be the subscriber
   application.
   Subscribe to squares, circles and triangles and observe how no data is
   received.

#. Now run |RS| to cause the aggregation data from the publisher application
   to the subscriber application.  Run the following command from the example
   build directory:

   ::

        <Connext directory>/bin/rtiroutingservice \
                -cfgFile ../RsShapesProcessor.xml \
                -cfgName RsShapesSplitter \
                -DSHAPES_PROC_KIND=splitter

   You should see how the subscriber application receives samples from squares,
   circles and triangles. The squares samples are exactly the same generated by
   the publisher application. The circles and triangles are samples are the
   result of the route that contains the *ShapesSplitter*.

   Note that we are using the configuration variable ``SHAPES_PROC_KIND`` to
   indicate which class we want to instantiate, and its value is provided
   with the ``-D`` command-line option.

#. Repeat the first step but publish other colors. You should observe the same
   behavior in the subscriber application for the new colors.

#. In the publisher application, delete all the *DataWriters*. You should
   see the instances being disposed. Now delete all *DataReaders* from the
   subscriber application.





    



